# OS

## 1. 进程与线程

```

```

## 2.进程调度算法

### 2.1 进程调度算法的性能衡量指标

```
T周转时间= T完成时间 − T到达时间
平均周转时间

T响应时间= T首次运行−T到达时间
```

### 2.2 调度算法

#### 2.2.1 先来先服务 FIFO

```
定义：哪个任务先来就先执行哪个

特点：实现简单
缺点：护航效应（convoy effect）
```

#### 2.2.2 最短作业优先 SJF

```
定义：先运行最短的任务，然后是次短的任务

缺点：护航效应（convoy effect）
```

#### 2.2.3 最短剩余时间优先 STCF

```
定义: 每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作

时钟中断：如果任务没有执行IO操作主动放弃使用CPU，即使是操作系统也无法获取到CPU的执行权，所以就有时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupthandler）会运行。此时，操作系统重新获得CPU的控制权。（基于硬件层面获取CPU控制权）

上下文切换：操作系统要为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。

特点：具有很好的周转时间，但是响应时间与交互性差
```

#### 2.2.4 时间片轮转法 Round-Robin,RR

```
定义：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成.

时间片长度对于RR是至关重要的，时间片越短，RR在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应

摊销技术（amortization）:通过减少成本的频度（即执行较少次的操作），系统的总成本就会降低。例如，如果时间片设置为10ms，并且上下文切换时间为1ms，那么浪费大约10%的时间用于上下文切换。如果要摊销这个成本，可以把时间片增加到100ms。在这种情况下，不到1%的时间用于上下文切换，因此时间片带来的成本就被摊销了
```

#### 2.2.5 优先级调度算法

```
优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。

在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：
1. 非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。
2. 剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。

而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：
1. 静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。
2. 动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。
```

